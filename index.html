<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>动态漂浮视频</title>
    <style>
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            overflow: hidden; /* 防止滚动条 */
        }

        .video-container {
            position: absolute; /* 关键：绝对定位 */
            width: 200px; /* 调整视频容器大小 */
            height: 150px;
            /*background-color: rgba(255, 0, 0, 0.2);*/ /*调试用*/
            border-radius: 10px;
            overflow: hidden;
        }

        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 填充容器 */
        }
    </style>
</head>

<body>

    <script>
        // 视频列表
        const videoUrls = [
            'https://files.catbox.moe/b73eoz.mp4',
            'https://files.catbox.moe/fz57ex.mp4',
            'https://rr2---sn-vgqskn7l.googlevideo.com/videoplayback?expire=1716507393&ei=aP7CZt2tJ5e71gL04o3ACg&ip=172.253.114.104&id=o-AI63B_F_D-HhqzY-j32i3q7w0n8f5L26_9iN_Q9fC885&itag=22&source=youtube&requiressl=yes&mh=gU&mm=31%2C29&mn=sn-vgqskn7l%2Csn-vgqs7n76&ms=au%2Crwu&mv=m&mvi=2&pl=24&initcwndbps=1315000&vprv=1&mime=video%2Fmp4&cnr=14&ratebypass=yes&dur=241.692&lmt=1685851830449415&mt=1716485458&fvip=2&fexp=24007246&c=WEB&txp=5531432&n=q54j-z8K90zQ5A&sparams=expire%2Cei%2Cip%2Cid%2Citag%2Csource%2Crequiressl%2Cmime%2Ccnr%2Cratebypass%2Cdur%2Clmt&sig=AOq0QJc6OwO8r2i_UjB33hY6M30y5yH5i151F_h0vXl0-n974wN08-4E08_m6b-46b44_30&redirect_counter=1&rm=sn-vgqskn7l&req_id=75f25485861ca3ee&cms_redirect=yes&ipbypass=yes&mip=2409:8a2c:1a62:c010:0:0:16a:a801&mmip=66&mnip=sn-vgqskn7l&msip=au&key=yt8&cpn=X0y9YtQss9V5xP_e&cver=2.20240522.08.0rc1'
        ];

        let videos = [];
        const videoCount = 10; // 视频数量
        const videoSize = 200; // 视频容器大小（正方形）
        const minSpeed = 0.5;
        const maxSpeed = 2;

        // 获取窗口尺寸
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;

        // 碰撞检测函数
        function checkCollision(video1, video2) {
            const rect1 = video1.getBoundingClientRect();
            const rect2 = video2.getBoundingClientRect();

            return !(rect1.right < rect2.left ||
                rect1.left > rect2.right ||
                rect1.bottom < rect2.top ||
                rect1.top > rect2.bottom);
        }

        // 创建视频元素
        function createVideo() {
            const container = document.createElement('div');
            container.classList.add('video-container');

            const video = document.createElement('video');
            video.src = videoUrls[Math.floor(Math.random() * videoUrls.length)]; // 随机选择视频
            video.autoplay = true;
            video.loop = true;
            video.muted = true; // 静音
            container.appendChild(video);

            document.body.appendChild(container);

            // 随机初始位置（避免超出边界）
            container.style.left = Math.random() * (windowWidth - videoSize) + 'px';
            container.style.top = Math.random() * (windowHeight - videoSize) + 'px';

            // 随机初始速度和方向
            const angle = Math.random() * 2 * Math.PI; // 随机角度
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const dx = Math.cos(angle) * speed;
            const dy = Math.sin(angle) * speed;

            return { container, video, dx, dy };
        }


        // 更新视频位置
        function updateVideoPosition(videoObj) {
            let { container, dx, dy } = videoObj;
            let x = parseFloat(container.style.left);
            let y = parseFloat(container.style.top);

            x += dx;
            y += dy;

            // 边界检测
            if (x < 0 || x > windowWidth - videoSize) {
                videoObj.dx = -dx;
            }
            if (y < 0 || y > windowHeight - videoSize) {
                videoObj.dy = -dy;
            }

            container.style.left = x + 'px';
            container.style.top = y + 'px';
        }

        // 处理碰撞
        function handleCollisions() {
            for (let i = 0; i < videos.length; i++) {
                for (let j = i + 1; j < videos.length; j++) {
                    if (checkCollision(videos[i].container, videos[j].container)) {
                        // 简单的反弹：交换速度向量
                        let dx1 = videos[i].dx;
                        let dy1 = videos[i].dy;
                        videos[i].dx = videos[j].dx;
                        videos[i].dy = videos[j].dy;
                        videos[j].dx = dx1;
                        videos[j].dy = dy1;

                        // 为了避免卡住，稍微移动一下位置
                        videos[i].container.style.left = (parseFloat(videos[i].container.style.left) + videos[i].dx) + 'px';
                        videos[i].container.style.top = (parseFloat(videos[i].container.style.top) + videos[i].dy) + 'px';
                        videos[j].container.style.left = (parseFloat(videos[j].container.style.left) + videos[j].dx) + 'px';
                        videos[j].container.style.top = (parseFloat(videos[j].container.style.top) + videos[j].dy) + 'px';


                    }
                }
            }
        }


        // 主循环
        function animate() {
            videos.forEach(updateVideoPosition);
            handleCollisions();
            requestAnimationFrame(animate);
        }

        // 初始化
        function initialize() {
            for (let i = 0; i < videoCount; i++) {
                videos.push(createVideo());
            }
            animate();
        }

        // 窗口大小改变事件
        window.addEventListener('resize', () => {
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            // 重新定位视频，避免超出边界
            videos.forEach(videoObj => {
                videoObj.container.style.left = Math.min(parseFloat(videoObj.container.style.left), windowWidth - videoSize) + 'px';
                videoObj.container.style.top = Math.min(parseFloat(videoObj.container.style.top), windowHeight - videoSize) + 'px';
            });
        });

        initialize();

    </script>

</body>

</html>